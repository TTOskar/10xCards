# REST API Plan

## 1. Resources

1. **User** (table: app.user)
   - Attributes: id, email, password_hash, role, failed_login_attempts, locked_until, created_at, deletion_requested_at, is_deleted, deleted_at
   - Notes: Row-level security (RLS) restricts access to owner or admin. 

2. **Deck** (table: app.deck)
   - Attributes: id, user_id, name, description, created_at, is_deleted, deleted_at
   - Relationships: Each deck belongs to a user. Unique constraint on (user_id, name).

3. **Card** (table: app.card)
   - Attributes: id, deck_id, front, back, source, interval, repetition_count, due_date, created_at, is_deleted, deleted_at
   - Relationships: Each card belongs to a deck. Source indicates whether the card was created manually or generated by AI. Field constraints enforce maximum lengths (front ≤ 200, back ≤ 1000).

4. **AIJob** (table: app.ai_jobs)
   - Attributes: id, user_id, input_text_length, token_count, flashcards_count, duration_ms, status, created_at
   - Function: Represents the AI processing job for generating flashcards from the submitted text.

5. **AIJobFlashcards** (table: app.ai_job_flashcards)
   - Attributes: id, ai_job_id, front, back, status, edited_front, edited_back, created_at
   - Function: Holds individual flashcards generated by an AIJob. Status can be 'accepted', 'edited', or 'rejected'.

6. **RateLimit** (table: app.rate_limit)
   - Attributes: id, user_id, window_start, request_count, text_characters, flashcard_count
   - Function: Enforces rate limits on API usage (e.g., AI text submissions, flashcard creation).

## 2. Endpoints

### A. Authentication and User Management

1. **User Registration**
   - **Method:** POST
   - **URL:** /api/auth/register
   - **Description:** Register a new user with email and password.
   - **Request Payload:**
     ```json
     {
       "email": "user@example.com",
       "password": "SecurePassword123"
     }
     ```
   - **Response:** 201 Created with user details (excluding password).
   - **Errors:** 400 Bad Request if validation fails.
   - **Business Logic:**
     - Validate email format and password strength.
     - Create a new user with default settings.

2. **User Login**
   - **Method:** POST
   - **URL:** /api/auth/login
   - **Description:** Authenticate and return a JWT token.
   - **Request Payload:**
     ```json
     {
       "email": "user@example.com",
       "password": "SecurePassword123"
     }
     ```
   - **Response:** 200 OK with JWT token.
   - **Errors:** 401 Unauthorized if credentials are invalid.
   - **Business Logic:**
     - Verify user credentials and generate a JWT token.
     - Enforce account lockout after consecutive failed attempts.

3. **Password Reset**
   - **Method:** POST
   - **URL:** /api/auth/forgot-password
   - **Description:** Initiate a password reset procedure by sending a reset link to the user's email.
   - **Request Payload:**
     ```json
     { "email": "user@example.com" }
     ```
   - **Response:** 200 OK message indicating reset link has been sent.
   - **Business Logic:**
     - Verify that the provided email exists.
     - Generate and send a secure password reset link.

### B. Deck Management

1. **List Decks**
   - **Method:** GET
   - **URL:** /api/decks
   - **Description:** Retrieve a paginated list of decks belonging to the authenticated user.
   - **Query Parameters:** Optional filtering/sorting (e.g., ?page=1&limit=10)
   - **Response:** 
     ```json
     {
       "data": [{ "id": 1, "name": "Deck Name", "description": "...", "created_at": "..." }],
       "pagination": { "page": 1, "limit": 10, "total": 25 }
     }
     ```
   - **Business Logic:**
     - Fetch decks associated with the authenticated user.
     - Support pagination and optional filtering.

2. **Create Deck**
   - **Method:** POST
   - **URL:** /api/decks
   - **Description:** Create a new deck for the user.
   - **Request Payload:**
     ```json
     {
       "name": "New Deck",
       "description": "Deck description"
     }
     ```
   - **Response:** 201 Created with deck details.
   - **Errors:** 400 Bad Request if name exceeds 100 characters or description exceeds 1000 characters.
   - **Business Logic:**
     - Validate deck name and description length constraints.
     - Associate the new deck with the correct user.

3. **Update Deck**
   - **Method:** PUT or PATCH
   - **URL:** /api/decks/{deckId}
   - **Description:** Update deck details (name, description).
   - **Request Payload:**
     ```json
     { "name": "Updated Deck Name", "description": "Updated description" }
     ```
   - **Response:** 200 OK with updated deck details.
   - **Business Logic:**
     - Validate update data and enforce name uniqueness per user.

4. **Delete Deck**
   - **Method:** DELETE
   - **URL:** /api/decks/{deckId}
   - **Description:** Soft-delete a deck (sets is_deleted flag).
   - **Response:** 204 No Content.
   - **Business Logic:**
     - Soft-delete the deck by marking it as deleted, preserving data integrity.

5. **Reset Deck Progress**
   - **Method:** POST
   - **URL:** /api/decks/{deckId}/reset-progress
   - **Description:** Reset progress for all cards within the deck (e.g., setting due dates and repetition counters to initial values).
   - **Response:** 200 OK with confirmation message.
   - **Business Logic:**
     - Reset card repetition counters and due dates to restart learning.

### C. Card Management

1. **List Cards**
   - **Method:** GET
   - **URL:** /api/cards
   - **Description:** Retrieve a paginated list of cards, with optional filtering (e.g., due today, overdue).
   - **Query Parameters:** e.g., ?deckId=1, ?filter=due_today, ?sort=created_at
   - **Response:** 
     ```json
     {
       "data": [{ "id": 10, "deck_id": 1, "front": "Front text", "back": "Back text", "due_date": "..." }],
       "pagination": { "page": 1, "limit": 10, "total": 50 }
     }
     ```
   - **Business Logic:**
     - Retrieve cards for a deck with options for filtering and pagination.

2. **Create Card (Manual)**
   - **Method:** POST
   - **URL:** /api/cards
   - **Description:** Create a single card manually with front and back texts.
   - **Request Payload:**
     ```json
     {
       "deck_id": 1,
       "front": "Question?",
       "back": "Answer.",
       "source": "manual"
     }
     ```
   - **Response:** 201 Created with card details.
   - **Errors:** 400 if front > 200 characters or back > 1000 characters.
   - **Business Logic:**
     - Validate that 'front' (≤200 chars) and 'back' (≤1000 chars) meet limits.
     - Record the card with a manual source indicator.

3. **Update Card**
   - **Method:** PUT or PATCH
   - **URL:** /api/cards/{cardId}
   - **Description:** Update the content of a card.
   - **Request Payload:**
     ```json
     { "front": "Updated front", "back": "Updated back" }
     ```
   - **Response:** 200 OK with updated card details.
   - **Business Logic:**
     - Update card details ensuring text length validations are met.

4. **Delete Card**
   - **Method:** DELETE
   - **URL:** /api/cards/{cardId}
   - **Description:** Soft-delete a card.
   - **Response:** 204 No Content.
   - **Business Logic:**
     - Soft-delete the card to remove it from active views without permanent loss.

5. **Bulk Delete Cards**
   - **Method:** DELETE
   - **URL:** /api/cards
   - **Description:** Delete multiple cards by providing an array of card IDs.
   - **Request Payload:**
     ```json
     { "ids": [10, 11, 12] }
     ```
   - **Response:** 204 No Content.
   - **Business Logic:**
     - Allow efficient removal of multiple cards in a single transaction.

### D. AI Flashcards Generation

1. **Generate Flashcards via AI**
   - **Method:** POST
   - **URL:** /api/ai/generate
   - **Description:** Generate flashcards based on pasted text (maximum 10,000 characters; max 5 requests/min).
   - **Request Payload:**
     ```json
     { "input_text": "Your long text here..." }
     ```
   - **Response:** 200 OK with a list of generated flashcards (each with front and back texts), AI job details, and statistics (e.g., token count, duration).
   - **Errors:** 400 Bad Request if text exceeds limit or API rate limit is reached.
   - **Business Logic:**
     - Validate input does not exceed 10,000 characters and enforce rate limits.
     - Interface with the AI engine to generate flashcards while respecting daily limits.

2. **Manage Generated Flashcards**
   - **a. View Generated Flashcards**
     - **Method:** GET
     - **URL:** /api/ai/jobs/{jobId}/flashcards
     - **Description:** Retrieve flashcards generated for a specific AI job.
     - **Response:** List of flashcards with statuses (accepted, edited, rejected).
   - **Business Logic:**
     - Retrieve the list of flashcards produced for a specific AI job.

   - **b. Update Flashcard Status (Accept/Edit/Reject)**
     - **Method:** PATCH
     - **URL:** /api/ai/flashcards/{flashcardId}
     - **Description:** Update the status of a generated flashcard. Optionally modify front/back if editing.
     - **Request Payload:**
       ```json
       { "status": "accepted", "edited_front": null, "edited_back": null }
       ```
     - **Response:** 200 OK with updated flashcard details.
   - **Business Logic:**
     - Allow users to review and modify the status or content of generated flashcards.

3. **Bulk Save Accepted Flashcards to a Deck**
   - **Method:** POST
   - **URL:** /api/ai/jobs/{jobId}/bulk-save
   - **Description:** Persist all flashcards marked as accepted into a designated deck. Ensures that daily limit (max 500 cards/day) is not exceeded.
   - **Request Payload:**
     ```json
     { "deck_id": 1 }
     ```
   - **Response:** 200 OK with summary of cards saved.
   - **Business Logic:**
     - Persist accepted flashcards into a chosen deck while ensuring daily limits are not exceeded.

### E. Spaced Repetition (SR) Session Endpoints

1. **Start SR Session**
   - **Method:** GET
   - **URL:** /api/srs/session
   - **Description:** Retrieve the next due flashcard for a spaced repetition session, filtered by deck or overall due status.
   - **Query Parameters:** e.g. ?deck_id=1
   - **Response:** 
     ```json
     { "card": { "id": 20, "front": "...", "back": "...", "due_date": "..." } }
     ```
   - **Business Logic:**
     - Identify and return the next due flashcard based on the spaced repetition algorithm.
     - Support optional filtering by deck.

2. **Submit SR Answer**
   - **Method:** POST
   - **URL:** /api/srs/session/answer
   - **Description:** Submit answer result (e.g., known, unknown, postpone) to update card's repetition data and due date according to the spaced repetition algorithm.
   - **Request Payload:**
     ```json
     { "card_id": 20, "result": "known" }
     ```
   - **Response:** 200 OK with updated card scheduling details.
   - **Business Logic:**
     - Process the study session result to adjust the card's repetition count and due date accordingly.

### F. Admin Endpoints (Protected: Admin Role Only)

1. **Manage Users**
   - **Method:** GET
   - **URL:** /api/admin/users
   - **Description:** Retrieve list of users along with account statuses, limits, and KPIs.
   - **Response:** Paginated list of users.
   - **Business Logic:**
     - Provide an overview of user accounts with relevant status and usage information.

2. **Lock/Unlock or Delete User Account**
   - **Method:** PATCH or DELETE
   - **URL:** /api/admin/users/{userId}
   - **Description:** Modify user account status (e.g., lock after 5 failed logins, delete account).
   - **Response:** 200 OK with status message.
   - **Business Logic:**
     - Allow secure modification of user account status by administrators.

3. **Reset User Limits**
   - **Method:** POST
   - **URL:** /api/admin/users/{userId}/reset-limits
   - **Description:** Manually reset the rate limits and flashcard counters for a user.
   - **Response:** 200 OK with confirmation.
   - **Business Logic:**
     - Enable administrators to reset API and flashcard usage limits for individual users.

4. **View KPI Dashboard**
   - **Method:** GET
   - **URL:** /api/admin/kpi
   - **Description:** Retrieve global and per-user KPIs (e.g., KPI-A and KPI-B as defined in the PRD).
   - **Response:** 200 OK with KPI details.
   - **Business Logic:**
     - Display key performance metrics and usage statistics for monitoring system health.

## 3. Authentication and Authorization

- **JWT Authentication:**
  - Implemented using Symfony Security and LexikJWTAuthenticationBundle.
  - Users obtain a JWT token on login which is required for all subsequent requests.
  - RLS policies in the database are enforced to restrict resource access to the owner or an admin.

- **Role-Based Access Control (RBAC):**
  - Regular users can only access and modify their own resources.
  - Admin endpoints are protected and require the user role to be 'admin'.

- **Rate Limiting:**
  - AI endpoints (e.g., text submission) and authentication endpoints include rate limiting enforced at both the API layer and via the RateLimit table in the database.

## 4. Validation and Business Logic

- **Field Validations (as per DB Schema):**
  - User email and password validations.
  - Deck: 'name' limited to 100 characters and 'description' to 1000 characters.
  - Card: 'front' limited to 200 characters and 'back' to 1000 characters.
  - AI-generated flashcards must adhere to these same limits.

- **Business Logic per PRD:**
  - **AI Flashcards Generation:** Validate maximum input text (10,000 characters) and enforce a rate of 5 requests per minute. Return up to 500 generated flashcards daily.
  - **Flashcard Acceptance/Editing:** Endpoints allow users to accept, edit, or reject AI-generated flashcards before saving them permanently.
  - **Bulk Operations:** Both bulk save and bulk delete endpoints ensure that only designated flashcards (e.g., accepted by AI) are processed, with checks against daily limits (max 500 cards/day).
  - **Spaced Repetition Session:** A dedicated session endpoint presents due flashcards and processes user responses (e.g., known, unknown, postpone) to adjust repetition counters and due dates.
  - **Deck Reset Progress:** A dedicated endpoint resets all cards in a deck to their initial state for a fresh start in learning.

- **Indexes and Performance Considerations:**
  - Endpoints involving filtering (e.g., decks by user, cards by due date) leverage database indexes such as idx_deck_user_id, idx_card_due_date, etc., to ensure acceptable performance.

- **Logging and Error Handling:**
  - All endpoints will log key operations and errors. Errors return appropriate HTTP status codes with clear JSON error messages.

---

*Assumptions*:
- The API adheres to RESTful principles and ensures clarity in payload structures.
- Both soft-deletion and RLS are applied at the data layer, so the API reflects these behaviors in responses and operations.
- Admin and user endpoints are clearly separated to ensure secure operation.

## 5. DTO Layer Recommendations

### A. DTO Structure
- All DTOs should be immutable (readonly properties)
- Use PHP 8.0+ constructor property promotion
- Separate Request and Response DTOs
- Use validation attributes for request validation
- Follow naming convention: Create<Entity>DTO, Update<Entity>DTO, etc.

### B. Common Base Classes
- ApiResponse - standardized wrapper for all API responses
- PaginationDTO - reusable pagination structure
- ErrorDTO - standardized error response format

### C. Validation Strategy
- Use PHP 8 attributes for validation
- Group validations by context (create/update)
- Validate at controller level using Symfony Validator
- Custom constraints for business rules

### D. Mapping Layer
- DTOMapper service for entity-DTO conversion
- Use Symfony Serializer for complex mappings
- Handle nested relationships appropriately
- Keep mapping logic centralized

### E. OpenAPI/Swagger Integration
- Add OpenAPI annotations to DTOs
- Generate API documentation from DTO structure
- Include validation rules in documentation
- Document response formats

### F. Form Integration
- Create FormType classes matching DTO structure
- Reuse validation rules between API and forms
- Handle file uploads consistently
- Support CSRF protection for web forms

*Note: These recommendations ensure consistency across the application while maintaining clean separation between layers.* 